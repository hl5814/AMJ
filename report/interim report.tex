%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Imperial Placement Report Template 
% LaTeX Template
% Version 1.0 (28/06/16)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[toc,page]{appendix}
\usepackage[margin=1in]{geometry}
\usepackage{enumitem}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage[hyphens]{url}
\usepackage{multicol}

\definecolor{lightgray}{rgb}{.93,.93,.93}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{HTML5}{
  language=html,
  sensitive=true,	
  alsoletter={<>=-},	
  morecomment=[s]{<!-}{-->},
  tag=[s],
  otherkeywords={
  >,
	<!DOCTYPE,
  </html, <html, <head, <title, </title, <style, </style, <link, </head, <meta, />,
	</body, <body,
	</div, <div, </div>, 
	</p, <p, </p>,
	</script, <script,
	</button,<button,
  <canvas, /canvas>, <svg, <rect, <animateTransform, </rect>, </svg>, <video, <source, <iframe, </iframe>, </video>, <image, </image>
  },
  ndkeywords={
  =,
  charset=, src=, id=, width=, height=, style=, type=, rel=, href=,
  fill=, attributeName=, begin=, dur=, from=, to=, poster=, controls=, x=, y=, repeatCount=, xlink:href=,
  margin:, padding:, background-image:, border:, top:, left:, position:, width:, height:,
  transform:, -moz-transform:, -webkit-transform:,
  animation:, -webkit-animation:,
  transition:,  transition-duration:, transition-property:, transition-timing-function:,
  },
}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\usepackage{xcolor}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}
\lstset{
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\lstdefinestyle{htmlcssjs} {%
  % General design
%  backgroundcolor=\color{editorGray},
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Code design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{editorGreen}\bfseries,
  stringstyle=\color{editorOcher}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Code
  language=HTML5,
  alsolanguage=JavaScript,
  alsodigit={.:;},	
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  % German umlauts
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
}
\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
\setlength{\topmargin}{0in}
\center % Center everything on the page
 
 
 \begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\hspace*{-0.5cm}
\end{flushleft}
\end{minipage}
~

%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

%\textsc{\LARGE MENG interim report}\\[1.5cm] % Name of your university/college
\textsc{\Large MENG individual project interim report}\\[0.5cm] % Major heading such as course name
\textsc{\large Department of Computing}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Malicious JavaScript Analyser}\\[0.4cm] % Title of your document
\HRule \\[1cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
 \textsc{Hongtao Li} \\ % Your name
hl5814 \\ [0.5cm]
\emph{CID:}\\
00940143
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.5\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Dr. \textsc{Sergio Maffeis } \\[0.5cm] % Supervisor's Name
\emph{Second Marker:} \\
\textsc{} % Supervisor's Name
\end{flushright}
\end{minipage}\\[1cm]

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[0.5cm] % Date, change the \today to a set date if you want to be precise


\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introduction}
JavaScript is highly dynamic, expressive language that supports real time evaluation and dynamic code generation at runtime. Today, JavaScript are not only been used in the development of large-scale web site such as Facebook but also used in different browser extensions. However the expressiveness and dynamic feature of JavaScript is often misused by attackers. The most widely used technique is the use of \textbf{eval} and \textbf{document.write} to convert runtime strings into invocable code. 
\subsection{Motivation}
In recently years, the number of JavaScript based malware attacks have increased. By exploiting numerous vulnerabilities in various web applications, attackers can launch a wide range of at­tacks such as cross-site scripting(XSS)\cite{XSS}, cross-site request forgery(CSRF)\cite{CSRF}, drive-by downloads \cite{Drive-by Downloads}, etc. And most Internet users rely on the anti-virus software. However,  most existing anti-virus software use static signature to prevent malicious JavaScript being executed. But attacker usually applies different JavaScript obfuscation techniques in order to hide the malicious content to evade detection. \\ \\
Apart from the language features, \textit{exploit kits}\cite{EK} allow attackers to create new exploits by using multiple existing exploits. Depending on the change, this can be easily accomplished within minutes. However, this also means there exists certain patterns behind the exploits. 
\subsection{Objectives}
In order to provide a reliable detection for malicious JavaScript, this project is to build a malicious JavaScript code Analyser that can not only classify a piece of JavaScript code into an known malicious class but also analysis the report malicious JavaScript patterns used. \\ \\
Malware cycle is an asymmetry loop between attackers and defenders. Once attackers develop the new malicious codes, they can always test it with the existing anti-virus engines until it can evade the detection. This project should be able to provide information about the relations between different patterns. In order to let the defenders to have a better understanding on how the patterns evolve with time. 
\subsection{Challenges}
JavaScript is embedded in web pages, except the script blocks, JavaScript codes can also exists in event handlers (e.g. button onclick event). Some malicious content may only be generated based on those events which means the malicious content can be hidden on the static perspective. So correctly detect a piece of JavaScript is malicious or not is the biggest challenge.
%**********************************************%
\newpage
\section{Background}
\subsection{JavaScript Obfuscation Techniques}
In order to find the malicious JavaScript patterns, we need to study the usage of different JavaScript obfuscation techniques in a systematic way. The following are the six categories based on different operations, more details can be found in\cite{ObfuscationTechniques}:
\begin{enumerate}
 	\item \textbf{Randomisation Obfuscation}: 
 	\begin{enumerate}
 		\item Insert some elements of JavaScript code such as white space \cite{WhiteSpaceRandomisation} and comments. (White space includes space character, tab, line feed, form feed and carriage return.) Because of JavaScript interpreters ignore white space characters and comments these changes won't affect the semantics of the code.
		\item Randomly replace variable and function name.  
 	\end{enumerate}
 	Attackers usually combine the above two randomise techniques together to increase the chance of evading the detection. Following code snippets have exactly same semantics but different static names.  \\
%------------------------------------------------------------------------------------
	\begin{tabular}{p{7cm}p{0.5cm}p{7cm}}
\begin{lstlisting}[language=JavaScript, title=(original code)]
function myFunction(name) {
    alert("Hello " + name);
}
var myName = "world";
myFunction(myName); 
			\end{lstlisting} & & 
			\begin{lstlisting}[language=JavaScript, title=(using randomisation)]
function _0xa88xj1(_0x94e9x2) {
    alert('Hello ' + _0x94e9x2)
}///random comment
var _763kkdi = 'world';
_0xa88xj1(_763kkdi)
			\end{lstlisting}
	\end{tabular} 
%------------------------------------------------------------------------------------
 	\item \textbf{Number Obfuscation}:  \\ 
 			Same number can be expressed in different ways by using basic arithmetic operations. (e.g. var x = 10, var x = 5+5, var x = 1000/100, etc.)
	\item \textbf{String Obfuscation}: \\
	String obfuscation techniques are widely used when people want to obfuscate JavaScript codes. Apart from some special string obfuscation based on JavaScript language behaviours. \\ (e.g. "(![]+[])[+[]]+(![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]" will be evaluated to string "fail"). The following are the two main categories of string obfuscation.
	\begin{enumerate}
 		\item \textbf{Encoding}: \\
 		 Encoding change the presentation of a string makes the code hard to interpret by humans but doesn't change the actual meaning of the string. This technique can be used to protect code privacy or intellectual property as well as to evade detection. 
		\begin{enumerate}
			\item URL Encoding(\% Encoding)
			\item Unicode Encoding
			\item Customised Encoding Function (decode during execution)
 		\end{enumerate}
 %------------------------------------------------------------------------------------
			\begin{lstlisting}[language=JavaScript, title=(encoding examples)]
var url_str = unescape("\%68\%65\%6C\%6C\%6F\%20\%77\%6F\%72\%6C\%64"));
var unicode_str = unescape("\%u0068\%u0065\%u006C\%u006C\%u006F\%u0020                          \%u0077\%u006F\%u0072\%u006C\%u0064");
var str = "hello world";
			\end{lstlisting}	
%------------------------------------------------------------------------------------
		\item  \textbf{String Manipulation}: \\
		Attackers could change the order of sub-strings and assign them with randomly generated variable names to make the code less human readable.
		\begin{enumerate}
			\item Concatenation: split a string into the concatenation of several sub-strings. Because of the dynamic feature of JavaScript, this usually used along eval() or document.write() to executed the concatenated string.
			\item Character Substitution: usually used with the replace() function and regular expression to substitute some of the characters in the given string before executing
 			\item Keyword Substitution: use a variable to substitute JavaScript keywords.
 		\end{enumerate}
%------------------------------------------------------------------------------------
	\begin{tabular}{p{7cm}p{0.5cm}p{7cm}}
			\begin{lstlisting}[language=JavaScript, title=(concatenation)]
var t2="ri"+"te"+"("+"\"";
var t3="hello"+"world"+"\""+");";
var t1="doc"+"um"+"ent"+"."+"w";
eval(t1+t2+t3);
			\end{lstlisting} & & \begin{lstlisting}[language=JavaScript, title=(character substitution)]
var str="!@h@e&&*l)l++ow?o/rld";
document.write(
    str.replace(/[^a-zA-Z0-9]/g,'')
);
			\end{lstlisting} \\ 
			\begin{lstlisting}[language=JavaScript, title=(keyword substitution)]
var test=document;
test.write("helloworld");
			\end{lstlisting}  & & \begin{lstlisting}[language=JavaScript, title=(original code)]
document.write("helloworld");
			\end{lstlisting} 
	\end{tabular}  	 		
%------------------------------------------------------------------------------------
 	\end{enumerate}
	\item \textbf{Obfuscated Field Reference}: \\
			JavaScript allows an object being accessed in two different ways: 
			\begin{enumerate}
				\item object.field
				\item object["field"]
			\end{enumerate}
			 So that the index expression may be computed and using string obfuscation stated above to obfuscate the code. \\
			\begin{lstlisting}[language=JavaScript, title=(obfuscated field reference example)]
document["write"]("helloworld");
document.write("helloworld");

var b = ['obj1', 'obj2'];
b.obj1 = "test1";
b.obj2 = "test2";
b['obj1'['replace'](/1/,'2')]; //"test2"
			\end{lstlisting}
	\newpage
	\item \textbf{Logic Structure Obfuscation}\cite{PowerOfObfuscationTechniquesInMaliciousJavaScriptCode}:\\
	Attackers may change the logic structure to manipulate the execution paths of JavaScript codes. This won't affect the original semantics. 
	\begin{enumerate}
			\item insert some instrucions which are independent to the functionality
			\item add/change some conditional branches
	\end{enumerate}
	
	\begin{lstlisting}[language=JavaScript, title=(logic structure obfuscation example)]
var i = 100;
if (i < 0) {
    alert("never!"); // dead code
}
for (i = 0; i < 100; i++) {
    if (i == 50) {
        document.write("helloworld");
    }
}
\end{lstlisting}
	The above example first inserts the independent instructions "if (i\textless 10) \{...\}" which are dead codes, used to complicate the execution path check. Then add an extra conditional branch inside the for loop "if (i==50) \{...\}" which will be executed.
	\item \textbf{Environment Interactions}\cite{Nofus}: \\
	JavaScript is embedded in web pages to be run for clients within a web browser. The DOM allows several types of obfuscation can be applied. Attackers can scatter the JavaScript codes across the HTML page using multiple \textless script\textgreater blocks to make it harder to reverse engineer (one script can be splitted into several script blocks or even loaded remotely from a file).  \\
	\begin{tabular}{p{4cm}p{0.02cm}p{4cm}p{0.02cm}p{5.6cm}}
			\begin{lstlisting}[language=JavaScript,alsolanguage=HTML5,  title=(self-contained block)]
<script>
var a="helloworld";
alert(a);
</script>
			\end{lstlisting} & & \begin{lstlisting}[language=JavaScript,alsolanguage=HTML5, title=(multiple script blocks) ]
<script>
var a="helloworld";
</script>
...
<script>
alert(a);
</script>
			\end{lstlisting}  & & \begin{lstlisting}[language=JavaScript,alsolanguage=HTML5,  title=(remote source file)]
<script src="helloworld.js">
</script>
...
<script>
alert(a);
</script>

[helloworld.js]
var a="helloworld";
			\end{lstlisting} 
	\end{tabular}  	 	
JavaScript can also be hidden in environment events. (e.g. button onclick event, etc.) This prevents the malicious code being detected by simply extracting the \textless script\textgreater blocks from the page. 
	\begin{lstlisting}[language=JavaScript,alsolanguage=HTML5, title=(script in events)]
<!DOCTYPE html>
<html>
<body>
  <button onclick="(function f() {alert('helloworld');})()">myButton</button>
</body>
</html>
  		\end{lstlisting} 	
\end{enumerate}
\newpage

\subsection{Benign and Malicious JavaScript}
JavaScript obfuscation techniques can be used in benign code as well. In order to protect code privacy or intellectual property, company will using some obfuscation techniques to reduce the readability of their JavaScript codes. Tool-kits such as JavaScript Obfuscator \cite{JSObfuscator} can be used to make the codes less human unreadable. So obfuscation doesn't imply malicious. We can't say a piece of code is malicious just because it is obfuscated.\\ \\
Malicious JavaScript code exploits obfuscation to hide its malicious intent to evade the detection and doesn't care the performance of the code after obfuscation while for benign codes they won't downgrading the execution performance by applying obfuscation.

\subsection{Existing Approaches} 
\subsubsection{Static Analysis}
The static analysis method checks the static characteristics and the structure of the JavaScript. But, exploits are frequently buried under multiple levels of JavaScript \textbf{eval}. Static analysis need to be performed on unfolded JavaScript codes to achieve better result. However, in order for a piece of JavaScript code being interpreted or compiled for execution, it needs to be decomposed into lexical tokens. The static analysis takes the advantages of this process via using the JavaScript lexical tokens directly without executing the script itself. This approach has negligible runtime overhead so it is widely used in browser extensions to block the malicious web pages.
\begin{multicols}{2}
\begin{lstlisting}[language=json,title=(tokens from Esprima)]
    {
        "type": "Keyword",
        "value": "var",
        "range": [0, 3]
    },
    {
        "type": "Identifier",
        "value": "x",
        "range": [4, 5]
    },
    {
        "type": "Punctuator",
        "value": "=",
        "range": [6,  7]
    },
    {
        "type": "Numeric",
        "value": "1",
        "range": [8,  9]
    },
    {
        "type": "Punctuator",
        "value": ";",
        "range": [9, 10]
    }
	\end{lstlisting} 
The code will be decomposed into Keywords, Punctuators, Identifiers and Literals follows the language specification of JavaScript \cite{JavaScript} sequentially.  \\ \\
For example, Esprima\cite{Esprima} is a high performance, standard-compliant JavaScript parser, if we use Esprima to parse "var x = 1" will produce the tokens on the left. We can see the type, value and the range of each token.  \\ \\
Based on those tokens, then we can provide further analysis based on rules and heuristics. For example, Support Vector Machines(SVM) based static analysis. Given benign and malicious codes as two sets of training data, an SVM can determines a hyperplane that separates both classes with maximum margin. After training, when feeding an unknown data to the SVM, it will map it to the vector space and classify it to either begin or malicious side of the hyperplane.
\end{multicols} 
\newpage
\noindent Since the actual name of variable or function doesn't change the semantic of the code itself, in Cujo\cite{Cujo}'s implementation those identifier tokens were replaced to the generic token \textbf{ID}. Similarly generic tokens \textbf{NUM} and \textbf{STR} are used instead of numerical literals and string literals respectively. To further strengthen the static analysis, they also record the length of each string literals (\textbf{STR.01} refers to a string with up to $10^1$ characters) and added \textbf{EVAL} in their tokens for feature extraction.   \\ 
\begin{tabular}{p{7cm}p{0.5cm}p{7cm}}
			\begin{lstlisting}[language=JavaScript, title=(original code)]
var x = 1;
var y = "helloworld";
var z = x + 15;
			\end{lstlisting} & & \begin{lstlisting}[language=JavaScript, title=(Cujo's implementation)]
ID = NUM;
ID = STR.01;
ID = ID + NUM;
			\end{lstlisting} 
	\end{tabular}  	 		
\\ 
And then based on the concept of q-grams to perform feature extraction where q is the length of each pattern (i.e. number of consecutive tokens). This allows us to find the top feature of a certain attack with the corresponding tokens.\\
\\
Another approach for feature extraction is based on the hierachical structure of JavaScript abstract syntax tree (AST) which is used in ZOZZLE\cite{ZOZZLE}. In ZOZZLE's implementation, a feature contains two things: the context which it appears (e.g. loops, conditional branches, try catch blocks, etc.) and the text of the AST node. 
\begin{multicols}{2}
\begin{lstlisting}[language=json,title=(AST from Esprima)]
Program body[1]
|--VariableDeclaration
    |--declarations[1]
		|--VariableDeclarator
		|	 |--id
		|		  |--Identifier
		|			   |--name:x
		|	 |--init
		|		  |--Literal
		|			   |--value:1
		|			   |--raw:1
		kind:var
	\end{lstlisting} 
Their implementation limits the possible number of features for a better performance. Only add to the feature set if the AST node is expression or variable declaration. Then using \textbf{Bayesian classifier} to run the classifier training.\\ \\ 
Left figure is a sample AST of a single variable declaration with initial value 1 (extracted from Esprima for "var x = 1"). They also add some pre-defined string patterns to speed up the matching process.
\end{multicols}
\noindent All purely statical based detector will fail to detect some attacks if the malicious pattern doesn't match any of the known features. And theses kind of statical analysis tools need to be kept trained with new evading techniques to continue to be effective.
\newpage
\subsubsection{Environment Analysis}
Web-based malware tends to be environment-specific which will attempt to fingerprint the version of the victim's software, for example, the browser and version of installed plug-ins. Following are the three main techniques attackers commonly used:
\begin{itemize}
  	\item \textbf{Environment matching}: the malicious JavaScript determines the capabilities of the browser and selectively alerts the content of the page. 
  	\item \textbf{Fingerprinting}: use a set of environment variables so that it is more comprehensive and detailed in its assessment. 
  	\item \textbf{Cloaking}\cite{Cloaking}: is a technique that allow the malicious JavaScript code to have different behaviours (show different content) depends on who is visiting the page.
\end{itemize}
Malwares are triggered infrequently, which is the fundamental limitation for detecting a piece of code is malicious. It only reveal itself when running in the specific environment. 
\begin{lstlisting}[language=JavaScript,title=(Example JavaScript that checks for specific environment)]
	var obj = null;
	try {
	    obj = new ActiveXObject("AcroPDF.PDF");
	} catch (e) {}
	if (!obj) {
	    try {
	        obj = new ActiveXObject("PDF.PdfCtrl");
	    } catch (e) {}
	}
	if (obj) {
	    document.write('<embed src="exploits/x18.php..." type="application/pdf" width=100 height=100></embed>');
	}
\end{lstlisting}
Rozzle\cite{Rozzle} focus on the environment analysis that explores multiple environment related paths within a single execution. Their goal is to increase the effectiveness of dynamic crawler searching for malware. \\ \\
Static analysis techniques that using AST can be performed to determining what conditions (e.g. if, try catch, etc.) in JavaScript code are environment-dependent.(focusing on  \textbf{ActiveXObject} calls and \textbf{navigator} object)
\newpage
\subsubsection{Function Invocation Based Analysis} 
Many of the obfuscation techniques stated above works because of the dynamic generation and runtime evaluation feature of JavaScript. However, those only works with the help of theses functions:
\begin{enumerate}
	\item JavaScript built in functions (e.g. \textbf{eval}, \textbf{usescape})
	\item DOM methods (e.g. \textbf{document.write})
\end{enumerate}
Apart from those built in functions. Due to the dynamic feature of JavaScript, user defined functions can also be invoked in multiple ways which also increase the difficulty of static checks. \\
	\begin{tabular}{p{7cm}p{0.5cm}p{7cm}}
			\begin{lstlisting}[language=JavaScript, title=(function plus1)]
// global defined function
function plus1(a) {
	return a+1;
}
			\end{lstlisting} & & \begin{lstlisting}[language=JavaScript, title=(passed as array element)]
function funObj(){
	this.f = plus1;
}
(new funObj).f(2); //3
			\end{lstlisting} \\ 
			\begin{lstlisting}[language=JavaScript, title=(passed as object field)]
var myArray = new Array(plus1, 1);
myArray[0](myArray[1]); //2
			\end{lstlisting}  & & \begin{lstlisting}[language=JavaScript, title=(passed as variable)]
var myVar = plus1;
myVar(3); //4
			\end{lstlisting} 
	\end{tabular}  
\\
The above example shows 3 different ways of invoking the same function. (function plus1 is pre-defined and in global scope). \\ \\
JStill\cite{JStill} focus on those malicious function arguments. Those malicious functions are called in a way that can hide their arguments from the static perspective. However, since both benign and malicious JavaScript codes using these techniques, the challenge is how to distinguish them. 
\subsubsection{Dynamic Analysis}
Because not all code can be statically observed, for example the code hidden within \textbf{eval} string. Another direction of malicious code detection is based on the dynamic analysis which will actually run the code and try to cover as many code paths as possible to trigger the malicious part. \\ \\
However, as mentioned in the previous section, attackers usually hide the malicious code using \textit{cloaking}\cite{Cloaking} techniques (only revealing the malicious content when the victim is using a specific version of the browser with a vulnerable plug-in). Therefore code coverage becomes the biggest challenge for dynamic analysis tools. \\ \\
A successful dynamic analysis tool must have a large code coverage (same code must be run within all combination of the browsers and plugins) in order to detect malicious content efficiently. Call back feature of JavaScript is also difficult to capture, attackers can load the attack code only when a specific mouse lick event is triggered. (More details about will be explained in GUI exploration section)	 
\paragraph{Symbolic Execution:} This technique is used to analysis a program to determine what inputs cause each part of the program execute (branches of code).\\ \\
In dynamic symbolic execution, user inputs are treated as symbolic variables. Dynamic symbolic execution differs from normal execution in that while many variable have their concrete values like 1 for an integer variable, the values of other variables which depend on symbolic inputs are represented by \textit{symbolic} formulas over the symbolic inputs, like $userinput$+1. Whenever any of the operands of a JavaScript operation is symbolic, the operation is simulated by creating a formula for the result of the operation in terms of the formulas for the operands.  
\subparagraph{For example:}
\begin{center}
\begin{tabular}{ |p{15cm}| } 
 \hline
Assume $x$ has symbolic value $input_{1}+1$. \\
For an assignment operation $y = x$:\\
\qquad the symbolic execution of the operation copies this value to $y$. ($y=input_{1}+1$)\\ \\
For an arithmetic operation $y = x + 5$:\\
\qquad the concrete values are calculated and symbolic part keep the same ($y=input_{1}+6$) \\ \\
(String and boolean are treated in the similar way) \\
\hline
\end{tabular}
\end{center}
\phantom \\
However, symbolically executing all feasible code paths does not scale to large application. The number of paths grows exponentially with an increase in program size. Therefore most tools that have symbolic executions generally use heuristics for path finding to reduce the execution cost and some use depth-limit to restrict the number of depths of execution performs.
\paragraph{Dynamic Symbolic Interpreter}
Before dynamic symbolic execution, the first step is to record the execution of the program with concrete inputs. JASIL\cite{JASIL} is an existing instrumentation component implemented in the web browser's JavaScript interpreter that can be used to record the semantics of the operations. It will capture all operations on integers, booleans, strings, arrays, as well as control-flows, object types, and calls to browser-native methods. \\
Once we have the recorded instructions we can run a symbolic interpreter to perform dynamic symbolic execution.
\newpage
\paragraph{Path Constraint Extractor}
A concrete boolean value (true or false) will be recorded along each control-flow branch (e.g. if and else) during the execution for indicating if the branch was taken. In symbolic execution, the corresponding branch condition is recorded by the path constraint extractor if it is symbolic. 
\begin{lstlisting}[language=JavaScript, title=(example path constrains) ]
	function checkNum(num) {
		if (num > 0) {				// (num > 0)
			if (num < 3) {
				return "small";		// (num > 0) AND (num < 3)
			} else {
				return "big";			// (num > 0) AND (num > 3)
			}
		}
		return "error";				// (num < 0)
	}
\end{lstlisting} 
Path constraint is the formula formed by conjoining the symbolic branch conditions (negating the conditions if branches that were not taken) as execution continues. If an input value satisfies the path constraint, then the program execution on that input will follow the same execution path.\\  \\ In the above example, if we take 2 as input which is greater than - and smaller than 3. Follow the path constraint for this input, we know the return value will be "small".
\begin{lstlisting}[language=JavaScript]
	var myNum = 2;		// (num > 0) AND (num < 3)
	checkNum(myNum);	// "small"
\end{lstlisting} 
Based on the path constrains, we can use constraint solver to perform symbolic executions on the application.
\paragraph{Multi-execution:}
The idea of multi-execution is to execute the program multiple times with different input values in order to discover how inputs affect the behaviour of the program. While Rozzle\cite{Rozzle} introduces single-pass multi-execution approach which execute both possibilities whenever it encounters control flow branching that is dependent on the environment. For example, in the case of if statement, both if and else branches will be executed. A key insight is to perform \textit{weak updates}. Assignments in different branches while execution will only update the original value which means multi-execution won't cause dependency issue. \\
\begin{tabular}{p{7.5cm}p{0.5cm}p{7.5cm}}
			\begin{lstlisting}[language=JavaScript, title=(original code)]
var a="hello";
var env=navigator.plugins[0].name;
if (env=="Chrome PDF Plugin") {
    a+="world"; 
} else {
    a+="!"; 
}
			\end{lstlisting} & & \begin{lstlisting}[language=JavaScript, title=(single-pass multi-execution) ]
var a="hello";
var env=navigator.plugins[0].name;
// if branch
a+="world"; 
// else branch
a="hello";
a+="!"; 
			\end{lstlisting} 
	\end{tabular}  
\newpage
\subsubsection{GUI Event Analysis}
In the DOM of most rich web applications, there are a variety of event handlers registered by different objects. For example, user can click on a button or submit a form. Event handler code may checks the state of GUI elements (e.g. check-box). User can trigger all those events in any order, and the application might have different behaviours. Some malicious content may only be triggered if victim triggers some events in certain order. This makes it very difficult to detect beforehand.
\begin{lstlisting}[language=JavaScript, title=(examples of finding and triggering GUI elements in DOM)]
// get all the DOM elements
var allElements = document.getElementsByTagName('*');

// loop over all items and printout the one  registered with onclick event
for (var i = 0; i < allElements.length; i++) {
	if (allElements[i].onclick) {
		console.log(allElements[i]);
	}
}

// check if a check-box is checked
document.getElementById("myCheck").checked;

// trigger an onclick event
document.getElementById("myButton").click();
\end{lstlisting}
Kudzu \cite{Kudzu} develop a GUI explorer that searches the space of all event sequences using a random exploration strategy (randomly selects an ordering among the user events registered by the web page. ) \\ \\
One challenge is that event handler might be created or deleted during code execution. (i.e. after click the button, a new form object might be created or deleted  in DOM). So if we could determine the priority of events, we can improve the efficiency of exploration. (in the previous example, the button that creates the new form should have higher priority then the form)
\newpage
\subsection{Statistics Models}
\paragraph{$\chi^{2}$ algorithm:} 
This model is commonly used for testing correlation between features and malicious code. $\chi^{2}$ test for one degree of freedom is described below:
\begin{center}
\begin{tabular}{ |p{10cm}| } 
\hline
A = malicious contexts with feature \\
B = benign contexts with feature \\
C = malicious contexts without feature \\
D = benign contexts without feature \\
$$\chi^{2}=\frac{(A*D-C*B)^{2}}{(A+C)*(B+D)*(A+B)*(C+D)}$$ \\
\hline
\end{tabular}
\end{center}
\phantom \\
\paragraph{Bayesian statistics:} 
This model had been used for classifier to classify malicious code and benign code based on training sets by assuming all features are independent.  Even this assumption might not be true for example feature of string concatenation obfuscation might be related to feature of \textbf{eval} function call. However, surprisingly, this assumption has yielded good results in the past because of its simplicity which allows the classifier is efficient to train and run. \\ \\
The probability assigned to label $L_{i}$ for code fragment containing features $F_{1},...,F_{n}$ may be computed using Bayes rule as follows: \\
$$P(L_{i}|F_{1},...,F_{n})=\frac{P(L_{i})P(F_{1},...,F_{n}|L_{i})}{P(F_{1},...,F_{n})}$$
\phantom \\
\newpage
\section{Project Plan}
[16-Feb] Project review (with second marker)
\begin{itemize}
  	\item Start writing a minimal detector that can find all JavaScript codes from html page, 
  	\begin{itemize}
  		\item script blocks
  		\item *follow urls to fetch further script blocks [inject remote JavaScript])
  		\item *from events, e.g. button onclick, etc.
	\end{itemize}
	\item parse JS codes, capture features (esprima, closure)
	\item try to detect for one simple pattern
	\item let detector report useful informations (e.g. which pattern it found)
	\item test manually with known data samples
\end{itemize}
[23-March]	End of Spring Term
\begin{itemize}
	\item implement the main logic of the detector, add other patterns
	\item static analysis
	\item *include dynamic analysis
	\item *include machine learning
\end{itemize}
[30-April]	Start of Summer Term
\begin{itemize}
	\item Start Testing
		\begin{itemize}
  		\item Build the automatic test tools (scripts)
  		\item Run tests on the known data sets
	\end{itemize}
\end{itemize}
[14-May/18-May]	Project health check-up (with supervisor) [1 month before final report]
\begin{itemize}
	\item Evaluation \& Analysis performance
	\begin{itemize}
  		\item Analysis the results (Correctness, Efficiency, Performance)
  		\item *Compare with other existing tools
  		\item *Test on unknown web pages
	\end{itemize}
	\item Finish Final Report
\end{itemize}
[18-June]	Final Report
%**********************************************%
\newpage
\section{Evaluation plan}
Based on the prototype implementation, the planned evaluation as follows 
\subsection{Data Samples}
The first step is to prepare the testing data sets (benign and malicious web pages). For the malicious samples, manually check why is it malicious and mark the samples with corresponding labels. These labels will be used to compare with the result of the detector later.
\subsection{Correctness \& Effectiveness}
Test with the known samples, and compare the results, check for accuracy 
\begin{itemize}
  	\item true positive (correctly detected attacks)
  	\item false positive (non-malicious code that be detected as malicious)
  	\item false negative (malicious code that hasn't been reported)
\end{itemize}
Check the reported information from the detector (why the detector classify that piece of code as malicious, which pattern does it find, etc.) and compare it with the manually checked labels.
\\
(extentions: Compare with Other Existing Techniques)

\subsection{Performance}
If the detector is used in a browser, measuring the performance overhead in terms of the average increased loading time for web pages are important. (Need to get rid of  the random network latency, the time should be measured multiple times and take the average)
\\ \\
Execution time can be slitted into different stages for precise analysis
\begin{itemize}
  	\item Static Check time
  	\item Dynamic Check time
\end{itemize}
(Make sure the page is not loaded from the local cache.)

\newpage
\addcontentsline{toc}{section}{References}
\begin{thebibliography}{9}
\bibitem{XSS}
J. Grossman, R. Hansen, P. D.Petkov, A. Rager, and S. Fogie, XSS Attacks: 
\textit{Cross Site Scripting Exploits and Defense} 2007.

\bibitem{CSRF}
N. Jovanovic, E. Kirda, and C. Kruegel, "Preventing cross site request forgery attacks," in
\textit{Second IEEE Communications SocietylCreateNet Inte ational Con­ ference on Security and Privacy in Communication Networks(Securecomm)} , September 2006, pp. 1-10.

\bibitem{Drive-by Downloads}
N. Provos,   Mavrommatis, M. A. Rajab, and F. Mon­ rose, "All your iframes point to us." in
\textit{USENIX Security Symposium} , 2008, pp. 1-15.

\bibitem{EK}
V. Kotov and F. Massacci. Anatomy of exploit kits: Preliminary analysis of exploit kits as software artefacts. In
\textit{International Conference on Engineering Secure Software and Systems}, 2013.

\bibitem{Cujo}
K. Rieck, T. Krueger, and A. Dewald. Cujo: Efficient de- tection and prevention of drive-by-download attacks. in
\textit{Proceedings of the Annual Computer Security Applica- tions Conference} , 2010.

\bibitem{ZOZZLE}
Curtsinger, C., Livshits, B., Zorn, B., and Seifert, C. Zozzle: Fast and precise in-browser javascript malware detection. in
\textit{In Proceedings of the 20th conference on USENIX security symposium} , (2011), USENIX Association..

\bibitem{Nofus}
Kaplan, S., Livshits, B., Zorn, B., Siefert, C., and Curtsinger, C. ”nofus: Automatically detecting” + string.fromcharcode(32) +”obfuscated ”.tolowercase() + ”javascript code”. in
\textit{Tech. rep., Microsoft Research} , 2011.

\bibitem{Kudzu}
Saxena, P., Akhawe, D., Hanna, S., Map, F., McCamant, S., and Song, D. A symbolic execution framework for javascript. in
\textit{Security and Privacy (SP), 2010 IEEE Symposium on} , 2010.

\bibitem{WhiteSpaceRandomisation}
B. Feinstein and D. Peck, "Caffenie monkey: auto­ mated collection detection and analysis of malicious javascript," in
\textit{Black Hat} , 2007.

\bibitem{PowerOfObfuscationTechniquesInMaliciousJavaScriptCode}
W. Xu F. Zhang and S. Zhu "The power of obfuscation techniques in malicious javascript code: A measurement study " in 
\textit{Proceedings of the 2012 7th International Conference on Malicious and Unwanted Software (MALWARE) ser. MALWARE '12. Washington DC USA: IEEE Computer Society } , 2012 pp. 9-16..

\bibitem{ObfuscationTechniques}
F. Howard. Malware with your Mocha? obfuscation and anti emulation tricks in malicious JavaScript.
\path{https://www.sophos.com/en-us/medialibrary/PDFs/technical%20papers/malware_with_your_mocha.pdf} ,Sept. 2010.

\bibitem{JavaScript}
Standard ECMA-262: ECMAScript Language Specifi- cation (JavaScript). 
\textit{3rd Edition, ECMA International}, 1999.

\bibitem{JStill}
W. Xu F. Zhang and S. Zhu "Still: Mostly Static Detection of Obfuscated Malicious JavaScript code" in
\textit{San Antonio, Texas,},  2013

\bibitem{Esprima}
Esprima
\path{http://esprima.org}

\bibitem{Cloaking}
WANG, D. Y., SAVAGE, S., AND VOELKER, G. M. Cloak and dagger: dynamics of web search cloaking. In 
\textit{Proceedings of the 18th ACM conference on Computer and communications security (2011)}, ACM, pp. 477–490.

\bibitem{Rozzle}
C. Kolbitsch, B. Livshits, B. Zorn, and C. Seifert. Rozzle: De-cloaking internet malware. In \textit{Security and Privacy (SP), 2012 IEEE Symposium on, pages 443–457. IEEE}, 2012.

\bibitem{JSObfuscator}
JavaScript-Source.com. 
\path{http: //javascript-source.com/}, 2009.

\bibitem{JASIL}
P. Saxena, S. Hanna, P. Poosankam, and D. Song. FLAX: Systematic discovery of client-side validation vulnerabilities in rich web applications. In 
\textit{17th Annual Network \& Distributed System Security Symposium, (NDSS)}, 2010.


\end{thebibliography}

\end{document}